using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

/*
    Qhashima is Viewer of statistics for computer shogi developped by Ryoto Sawada
*/

namespace Qhashima
{
    

    //対戦結果。将来的にfloodgateの不正終了を別途取り出す機能を加えたいのでenumしておく。
    enum Shogiresult
    {
        SENTE_WIN,
        GOTE_WIN,
        DRAW, //不正終了も現状全部drawとしてる
    }

    //棋譜ファイルのフォーマット
    enum Kifformat
    {
        UNDEFINED, //エラー値。初期値はこれ。
        SHOGIDOKORO, //将棋所
        SHOGIGUI, //将棋gui
        FLOODGATE, //floodgate
        SHOGIGUI_KAISEKI, //将棋guiを用いた解析
    }
    struct kif
    {
        public int[] scores; //評価値の推移
        public string[] players; //プレイヤー名（先手、後手の順番）
        public Shogiresult result;
        public Kifformat kifformat;
        public int plys; //ゲームの手数（注、あくまで、データとして入力された手の数！　勝ち負けとは関係ない）
        /*
            棋譜を読み込む。現時点でfloodgate、将棋所、将棋guiに対応してる
            他フォーマットへの対応は予定していない。githubにうｐすることで更新されるかを眺めるのも悪くない。
            人間の棋譜をコンピュータに解析させたものにも対応させたい。
            棋士ごとの序盤、中盤、終盤の強さなどを抽出できたら楽しそう。
            *** shogidokoroのフォーマット ***
            # KIF形式棋譜ファイル
            # Generated by Shogidokoro
            手合割：平手
            先手：YaneuraOu 2016 Mid  3.57 64AVX2
            後手：YaneuraOu 2016 Mid  3.57 64AVX2
            手数----指手---------消費時間--
            1 ２六歩(27)    (00:01 / 00:00:01) ←　手、評価値、pvの順に出る
            *0
            *▲２六歩(27)△８四歩(83)
            2 ３二金(41)    (00:01 / 00:00:01)
            *-83
            *BookEvalDiff = 30 , moves to 3 moves.
            3 ７六歩(77)    (00:01 / 00:00:02)
            *0
            *▲７六歩(77)△３四歩(33)
            4 ６二銀(71)    (00:01 / 00:00:02)
            *-76
            ...
            まで169手で先手の勝ち ←　最後に結果が出る

            *** shogiguiのフォーマット ***
            手合割：平手
            先手：Apery Debug Build
            後手：GPSfish 0.2.1+r2837 gcc 4.6.3 osl wordsize 32 gcc 4.6.3
            手数----指手---------消費時間--
            1 ４八銀(39)        ( 0:00/00:00:00)　←　手と評価値が交互に出る（はず）
            **対局 文字列 BookEvalDiff = 30 , moves to 4 moves.
            ...
            まで97手で先手の勝ち ←最後の行に結果が出る

            *** 棋譜解析 in shogiguiのフォーマット ***
            手合割：平手
            先手：Apery Debug Build
            後手：GPSfish 0.2.1+r2837 gcc 4.6.3 osl wordsize 32 gcc 4.6.3
            ↑最初の3行で対局者が出てくる。
              →実際の手　                                  59 ２三歩成(24)       ( 0:02/00:00:46)
              →対局したコンピュータの読みや評価値    　  　*1013
                                                            *▲２三歩成(24)△２二歩打▲４五歩(46)△５六馬(66)▲６四歩打△５四銀(63)▲７五歩(76)△同歩(74)▲７四歩打△同馬(56)▲２二と(23)△３三桂(21)▲２三飛成(26)△４五飛(42)▲１一と(22)△４九飛成(45)▲３三龍(23)△２九龍(49)
              →解析用AIの読み                              **解析 ○ 時間 00:00.1 深さ 14/24 ノード数 410383 評価値 910 読み筋 △２二歩打 ▲４五歩(46) △同　飛(42) ▲６四歩打 △５四銀(63) ▲７五歩(76) △４六歩打 ▲７四歩(75) △４七歩成(46) ▲７三歩成(74) △同　銀(72) ▲７四歩打 △同　銀(73) ▲６三歩成(64) △３七と(47) ▲５二と(63) △同　金(61) ▲２二と(23) △５七角打 
                                                            **候補手  時間 00:00.1 深さ 14/22 ノード数 439735 評価値 844 読み筋 ▲２三歩成(24) △２二歩打 ▲４五歩(46) △５六馬(66) ▲６四歩打 △５四銀(63) ▲３五歩(36) △４七馬(56) ▲７五歩(76) △同　歩(74) ▲７四歩打 △同　馬(47) ▲２二と(23) △４五飛(42) ▲２一と(22) 
              ...
              まで97手で先手の勝ち ←最後の行に結果が出る

            *** floodgateのフォーマット ***
            ...
            &#39;black_rate:Aqours+e71046987e71a6091ac233864a318bb2:3304.0
            &#39;white_rate:SILENT_HIRAOKA_20160917_2700K+db56dc4fdad144a8b430d26d16c3b40c:3354.0
            ↑ 上記のような行から対局者名を抽出できる
            +6978KI ←　指し手、時間（ここまでは必ず出る）、ソフトの評価値の順番で出る（出ないソフトもある。そういうのは素直に捨てよう）
            T0
            '** 36 -8384FU +2726FU -8485FU +2625FU -4132KI +5958OU -5152OU +2524FU -2324FU +2824HI -0023FU +2428HI -3334FU +0024FU -2324FU +2824HI -8586FU +8786FU -8286HI +0087FU
            &#39;summary:toryo:Aqours win:SILENT_HIRAOKA_20160917_2700K lose　←対局が無事に終わるとこんなコメントが出る

            *** Qhashimaの判別ルーチン （16/10/13 ver）***
            １．Shogidokoroの文字が出てきたら将棋所フォーマットとする
            ２．V2のみの行があったらfloodgateとみなす
            ３．将棋所とみなされていない状態で「先手：」の文字を見つけたら将棋guiとみなす
            ４．将棋guiとみなされた状態で「解析」の文字を見つけたら解析データを読むものとみなす。
            
        */
        public static void kifread(string filename, ref kif inkif)
        {
            //kifデータの初期化
            //kifのサイズ。inputの手数が300以内とは限らないので本当はもっと大きい方がいい。
            inkif.scores = new int[300];
            inkif.players = new string[2];

            string line;
            inkif.kifformat = Kifformat.UNDEFINED;
            inkif.result = Shogiresult.DRAW;
            int ply = 0; //手数に相当する。指し手と思しき手が出るたびに1増える。
            bool kifstart = false; //手の読み込み開始（棋譜フォーマット、対局者が決まったらtrueに）

            System.IO.StreamReader file =
             new System.IO.StreamReader(filename, System.Text.Encoding.GetEncoding("shift_jis"));
            while ((line = file.ReadLine()) != null)
            {
                int value = 0; //評価値
                bool isWrite = false; //手が更新されたか

                if (ply == 0)
                {
                    //読み込んだファイルの解析

                    if (line.IndexOf("Shogidokoro") != -1)
                    {
                        inkif.kifformat = Kifformat.SHOGIDOKORO;
                    }

                    if (line == "V2")
                    {
                        inkif.kifformat = Kifformat.FLOODGATE;
                        //V2の真後ろ2行に先手後手の名前があるはずなので取得する。
                        for (int plloop = 0; plloop < 2; ++plloop)
                        {
                            string plnameline = file.ReadLine();
                            plnameline = plnameline.Substring(2, plnameline.Length - 2); //N+,N-の文字を除外
                            inkif.players[plloop] = plnameline;
                        }
                        kifstart = true;
                        continue;

                    }

                    //先手、後手の抽出。将棋所、将棋guiは「先手：」「後手：」の後ろにプレイヤー名が入る
                    if (line.IndexOf("先手") != -1)
                    {
                        if (inkif.kifformat == Kifformat.UNDEFINED)
                        {
                            inkif.kifformat = Kifformat.SHOGIGUI;
                        }
                        inkif.players[0] = line.Substring(3, line.Length - 3);
                        continue;
                    }

                    if (line.IndexOf("後手") != -1)
                    {
                        inkif.players[1] = line.Substring(3, line.Length - 3);
                        string plnameline = file.ReadLine();
                        kifstart = true;
                        continue;
                    }
                }

                /*
                       評価値の読み込み    
                */
                if (kifstart)
                {

                    //投了に関する判定
                    if (line.IndexOf("先手") != -1)

                    {
                        inkif.result = Shogiresult.SENTE_WIN;
                        break;
                    }

                    if (line.IndexOf("後手") != -1)
                    {
                        inkif.result = Shogiresult.GOTE_WIN;
                        break;
                    }

                    if (inkif.kifformat == Kifformat.FLOODGATE && line.IndexOf("summary:toryo") != -1)
                    {
                        //勝者の名前の文字列を取り出すのはとても面倒なので手数で判断。判断として聊か雑。
                        if (ply % 2 == 0)
                        {
                            inkif.result = Shogiresult.GOTE_WIN;
                        }
                        else
                        {
                            inkif.result = Shogiresult.SENTE_WIN;
                        }
                    }

                    if (inkif.kifformat == Kifformat.SHOGIDOKORO)
                    {
                        
                        if (line.IndexOf("*") == -1)
                        {
                            if (line.Length < 2) { continue; } //EOF周りのスタック防止   
                            if (line.IndexOf("投了") != -1)
                            {
                                continue; //投了している場合
                            }
                            //"*"から始まらない行は指し手を書いているはず
                            isWrite = true; ++ply;
                            string valueline = file.ReadLine(); //次の行に評価値が書いてあるはず
                                                                //評価値が出力されない場合、恐らくvalue lineはpvとかコメントとかになってるはず。
                                                                //これが数字であるか否かを完璧に判別するのは怠いので、とりあえず文字数で弾く

                            if (valueline.Length < 10)
                            {
                                if (valueline.IndexOf("Mate") != -1)
                                {
                                    //自分の勝ちを読み切った
                                    if (valueline.IndexOf("+") != -1)
                                    {
                                        value = 30000;
                                    }
                                    else {
                                        //自分の負けを読み切った
                                        value = -30000;
                                    }
                                }
                                else
                                {
                                    int t;
                                    if(!int.TryParse(valueline.Substring(1, valueline.Length - 1), out t)) { continue; }
                                    value = int.Parse(valueline.Substring(1, valueline.Length - 1));
                                }
                            }
                        }
                    }


                    if (inkif.kifformat == Kifformat.SHOGIGUI_KAISEKI)
                    {
                        if (line.IndexOf("解析") != -1 && line.IndexOf("評価値") != -1 && line.IndexOf("読み筋") != -1)
                        {
                            isWrite = true; ++ply;
                            int start = line.IndexOf("評価値");
                            int end = line.IndexOf("読み筋");
                            value = int.Parse(line.Substring(start, end - start));
                        }
                    }

                    if (inkif.kifformat == Kifformat.SHOGIGUI)
                    {
                        if (line.IndexOf("*") == -1)
                        {
                            if (line.Length < 2) { continue; } //EOF周りのスタック防止   
                            if (line.IndexOf("投了") != -1)
                            {
                                continue; //投了している場合
                            }
                            //"*"から始まらない行は指し手を書いているはず
                            isWrite = true; ++ply;
                            string valueline = file.ReadLine();
                            int start = valueline.IndexOf("評価値");
                            int end = valueline.IndexOf("読み筋");
                            if (start != -1 && end != -1)
                            {
                                string hoge = valueline.Substring(start + 4, end - start - 4);
                                if (valueline.IndexOf("詰") != -1)
                                {
                                    //自分の勝ちを読み切った
                                    if (valueline.IndexOf("+") != -1)
                                    {
                                        value = 30000;
                                    }
                                    else {
                                        //自分の負けを読み切った
                                        value = -30000;
                                    }
                                }
                                else
                                {
                                    // fail-high、fail-low対応
                                    hoge = hoge.Replace("↑", "").Replace("↓", "");

                                    int t;
                                    if (!int.TryParse(hoge, out t)) { value = 0;  continue; }
                                    value = int.Parse(hoge);
                                }
                                
                                
                            }
                        }
                        //解析用のフォーマットが見つかったらそっちへモード移行する
                        if (line.IndexOf("解析") != -1 && line.IndexOf("評価値") != -1 && line.IndexOf("読み筋") != -1)
                        {
                            isWrite = true; //上書きする
                            int start = line.IndexOf("評価値");
                            int end = line.IndexOf("読み筋");

                            value = int.Parse(line.Substring(start, end - start));
                            inkif.kifformat = Kifformat.SHOGIGUI_KAISEKI;
                        }

                    }

                    if (inkif.kifformat == Kifformat.FLOODGATE)
                    {
                        if (line.StartsWith("T"))
                        {
                            ++ply;
                        }
                        if (line.IndexOf("**") != -1)
                        {
                            isWrite = true;
                            string hoge = line.Substring(line.IndexOf("**")+3, line.Length - line.IndexOf("**")-3);
                            int len = hoge.IndexOf(" ");
                            if (len == -1)
                            {
                                value = 0;
                            }
                            else {
                                int t;
                                if (!int.TryParse(hoge, out t)) { value = 0; continue; }
                                value = int.Parse(hoge.Substring(0, len));
                            }

                        }
                    }

                    //評価値のデータベースに追加
                    if (isWrite)
                    {
                        inkif.scores[ply - 1] = ((ply-1)%2==0 ? value : -value);
                    }
                }
            }
            inkif.plys = ply;

            file.Close();
            
        }
    }
    //評価値プロット用のデータ。先手の評価値、後手の評価値、手数の3つからなる。
    //N手目の評価値を厳密に持っているのは片方のplayerだけなので、もう片方のplayerはひとつ前の手での評価値を使う。
    struct kifplot
    {
        public int score1;
        public int score2;
        public int ply;
        public int whichwin; //何方が勝ったか
    }

    //結果の統計データ。棋譜読み込みと一緒に作ってしまうかは要検証
    //恐らく、作らなく良い。物凄く沢山棋譜があった時に落ちるとウザいから
    //オプションで読み込みと同時に統計をすべて出すというのはあっても良いかも。
    struct statistics
    {
        public string[] players; //プレイヤー
        public int[] winrate; //player1の勝ち数、2の勝ち数、引き分け数
        public kifplot[] plots; //kifplot形式の評価値纏め
        public int plotcnt;
    }

    public partial class Form1 : Form
    {
        //棋譜を読み込むフォルダ名
        string foldername;
        kif[] kifs;//棋譜データ
        string[] files; //ファイル名一覧
        statistics stinfo; //統計データ一覧

        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {

        }

        private void Folderselector_Click(object sender, EventArgs e)
        {
            //ダイアログを表示する
            if (Kiffolder.ShowDialog(this) == DialogResult.OK)
            {
                //選択されたフォルダを表示する
                foldername = Kiffolder.SelectedPath;
                Kiflabel.Text = foldername;

                //選択されたフォルダのファイル名をすべて取得する
                //とりあえずkifとcsaに対応。
                files = System.IO.Directory.GetFiles(
                foldername, "*.kif"
#if false
	, System.IO.SearchOption.AllDirectories
#endif
                ).Concat(System.IO.Directory.GetFiles(
                foldername, "*.csa"
#if false
                , System.IO.SearchOption.AllDirectories
#endif
                )).ToArray();

                //リストに結果を表示する
                Kiflist.Items.AddRange(files);
            }
        }

        private void Readkif_Click(object sender, EventArgs e)
        {
            kifs = new kif[files.Length];
            int findex=0;
            foreach (string fname in files)
            {
                kif.kifread(fname, ref kifs[findex]);
                ++findex;
                Readinfo.Text = findex.ToString() + "/" + files.Length;
            }
            
            findex = 0;
        }

        private void Search_AI_Click(object sender, EventArgs e)
        {
            //256手以上かかる戦いをないと仮定している。本当は良くない。
            stinfo.plots = new kifplot[files.Length*256];
            stinfo.plotcnt = 0;
            stinfo.winrate = new int[3];
            stinfo.winrate[0] = stinfo.winrate[1] = stinfo.winrate[2] = 0;
            for (int i = 0; i < files.Length; ++i)
            {
                int gstat = -1;
                //壊れた棋譜ファイルを読み込んでいると、playersがnullになるらしいので、此処ではじく
                if(kifs[i].players[0]==null || kifs[i].players[1] == null) { continue; }
                if (Findname(kifs[i].players[0],AIname1.Text) && Findname(kifs[i].players[1], AIname2.Text))
                {
                    gstat = 0; //AIname1が先手でAIname2が後手
                }
                if (Findname(kifs[i].players[1], AIname1.Text) && Findname(kifs[i].players[0], AIname2.Text))
                {
                    gstat = 1; //AIname1が後手でAIname2が先手
                }
                if (gstat == -1) { continue; }
                //勝率の計算
                if (kifs[i].result == Shogiresult.DRAW)
                {
                    stinfo.winrate[2] += 1;
                }
                else if ((gstat == 0 && kifs[i].result == Shogiresult.SENTE_WIN) || (gstat == 1 && kifs[i].result == Shogiresult.GOTE_WIN))
                {
                    stinfo.winrate[0] += 1;
                }
                else
                {
                    stinfo.winrate[1] += 1;
                }
                //各々の手のプロット
                for (int ply = 0; ply < kifs[i].plys; ++ply)
                {
                    if (kifs[i].result == Shogiresult.DRAW)
                    {
                        stinfo.plots[stinfo.plotcnt].whichwin = 0;
                    }
                    else if ( (kifs[i].result == Shogiresult.SENTE_WIN && gstat==0) || (kifs[i].result == Shogiresult.GOTE_WIN && gstat == 1)){
                        stinfo.plots[stinfo.plotcnt].whichwin = 1;
                    }
                    else
                    {
                        stinfo.plots[stinfo.plotcnt].whichwin = 2;
                    }
                    bool senteturn = (ply % 2 == 0);
                    bool isscore1 = ((senteturn && gstat == 0) || (!senteturn && gstat == 1));
                    if (isscore1)
                    {
                        stinfo.plots[stinfo.plotcnt].score1 = kifs[i].scores[ply];
                        stinfo.plots[stinfo.plotcnt].score2 = (ply != 0 ? kifs[i].scores[ply - 1] : 0);
                    }
                    else
                    {
                        stinfo.plots[stinfo.plotcnt].score2 = kifs[i].scores[ply];
                        stinfo.plots[stinfo.plotcnt].score1 = (ply != 0 ? kifs[i].scores[ply - 1] : 0);
                    }
                    stinfo.plots[stinfo.plotcnt].ply = ply;
                    stinfo.plotcnt += 1;
                }
            }
            //読み込み終了
            //ラベルか何かに勝率を書き出す
            Winlosestat.Text = stinfo.winrate[0].ToString() + "(" + AIname1.Text + ") vs" + stinfo.winrate[1].ToString() + "(" + AIname2.Text + ") draw = " + stinfo.winrate[2].ToString();
        }

        private void Outputplots_Click(object sender, EventArgs e)
        {
            if (saveFileDialog.ShowDialog(this) == DialogResult.OK)
            {
                int ply = (int) numericUpDown1.Value-1;
                System.IO.StreamWriter sw = new System.IO.StreamWriter(saveFileDialog.FileName);
                sw.WriteLine(AIname1.Text + "," + AIname2.Text);
                sw.WriteLine(stinfo.winrate[0].ToString() + "(" + AIname1.Text + ") vs" + stinfo.winrate[1].ToString() + "(" + AIname2.Text + ") draw = " + stinfo.winrate[2].ToString());
                sw.WriteLine("Ply = " + numericUpDown1.Value.ToString());
                for(int i = 0; i < stinfo.plotcnt; ++i)
                {
                    if(stinfo.plots[i].ply != ply) { continue; }
                    sw.WriteLine(stinfo.plots[i].score1.ToString() + "," + stinfo.plots[i].score2.ToString()+"," + stinfo.plots[i].whichwin.ToString());
                }
                sw.Close();
            }
        }

        private void OutstatByValue_Click(object sender, EventArgs e)
        {
            WriteStatByValue(-1);
        }

        private bool Findname(string db_name, string search_name)
        {
            if (search_name == "*") { return true; }
            return (db_name.IndexOf(search_name) != -1);
        }

        private void WriteStatByValue(int Plyfilter)
        {
            int[] wink = new int[40];
            int[] losek = new int[40];
            int[] wink2 = new int[40];
            int[] losek2 = new int[40];

            if (saveFileDialog.ShowDialog(this) == DialogResult.OK)
            {
                
                System.IO.StreamWriter sw = new System.IO.StreamWriter(saveFileDialog.FileName);
                sw.WriteLine(AIname1.Text + "," + AIname2.Text);
                sw.WriteLine(stinfo.winrate[0].ToString() + "(" + AIname1.Text + ") vs" + stinfo.winrate[1].ToString() + "(" + AIname2.Text + ") draw = " + stinfo.winrate[2].ToString());
                sw.WriteLine("Win-lose-stat by value");
                for (int i = 0; i < stinfo.plotcnt; ++i)
                {
                    if(Plyfilter != -1 && Plyfilter != stinfo.plots[i].ply) { continue; }
                    int index1 = (stinfo.plots[i].score1 + 1000) / 50;
                    int index2 = (stinfo.plots[i].score2 + 1000) / 50;
                    if(index1 >= 0 && index1 < 40)
                    {
                        if (stinfo.plots[i].whichwin == 1) { wink[index1] += 1; }
                        if (stinfo.plots[i].whichwin == 2) { losek[index1] += 1; }
                    }
                    if (index2 >= 0 && index2 < 40)
                    {
                        if (stinfo.plots[i].whichwin == 2) { wink2[index2] += 1; }
                        if (stinfo.plots[i].whichwin == 1) { losek2[index2] += 1; }
                    }
                }
                for(int i = 0; i < 40; ++i)
                {
                    sw.WriteLine((-975+i*50).ToString()+","+(((double)wink[i]/((double)wink[i]+ (double)losek[i]))).ToString() + "," +(((double)wink2[i] / ((double)wink2[i] + (double)losek2[i]))).ToString()+","+wink[i].ToString()+"," + losek[i].ToString() + "," + wink2[i].ToString() + "," + losek2[i].ToString() + ",");

                }
                sw.Close();
            }
        }

        private void StatByValueWithPlyfilter_Click(object sender, EventArgs e)
        {
            int ply = (int)numericUpDown1.Value - 1;
            WriteStatByValue(ply);
        }
    }
}
